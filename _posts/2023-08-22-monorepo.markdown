---
layout: post
title: monorepo 
date: 2023-08-30 19:21:00 +0900
category: blog
image:  /assets/images/blog/2023/monorepo-1.png
author: 서준일
tags:   
    - Monorepo
    - nx
    - pnpm
desc: monorepo 구조는 두 개 이상의 프로젝트가 동일한 저장소에 저장되는 소프트웨어 개발 전략
---

# 1. Monorepo ?

## 1.1 Monorepo에 들어가기 앞서 ..

### monolithic application
- 모듈화 없이 설계된 app
- 코드가 서로 직접적으로 의존하며 단하나의 버전으로 관리, 관심분리가 어려워짐
- 설계, 리팩토링, 배포 등의 작업을 매번 거대한 단위로 처리 필요

### modular programming
- monolithic app의 한계를 모듈화를 통해 해결한 기법
- 모듈화를 통해 애플리케이션 로직의 일부를 재사용할 수 있도록 지원하고 전체 교체 없이 애플리케이션의 일부를 수정 또는 교체할 수 있게 해 유지관리를 용이하게 함.

### multirepo

- modular programming에서 각 모듈을 여러 repo로 각각 관리하는 방식
- 각 프로젝트는 자율성이 높으며 독립적인 개발, 린트, 테스트, 빌드, 게시, 배포 파이프라인이 존재
- 단점
    - **번거로운 프로젝트 생성**
    새로운 모듈 생성시마다 저장소 생성 > 커미터 추가 > 개발 환경 구축 > CI/CD 구축 > 빌드 > 패키지 저장소에 publish 과정 거쳐야함
    - **패키지의 중복 코드 가능성**
    위의 번거로움을 피하기 위해 각 프로젝트에서 공통 구성 요소를 자체적으로 작성시 중복코드 발생 및 관리부담 증가
    - **관리 포인트 증가**
    늘어난 프로젝트 저장소의 수만큼 관리 포인트가 늘어난다. 린트, 테스트, 개발 모드 실행, 빌드, 게시, 배포 등의 과정을 저장소의 수만큼 반복
    - **일관성 없는 개발자 경험**
    각 프로젝트는 테스트 실행, 빌드, 테스트, 린트, 배포 등을 위해 고유한 명령 집합을 사용한다. 이러한 불일치는 여러 프로젝트에서 사용할 명령을 기억해야 하는 정신적 오버헤드를 만든다.
    - **다른 모듈의 변경 사항 파악 어려움**
    관련 패키지의 변화를 인지할 수 없음

## 1.2 Monorepo 란 ?

모노레포(monorepo) 구조는 두 개 이상의 프로젝트가 동일한 저장소에 저장되는 소프트웨어 개발 전략
단순히 여러 프로젝트가 하나의 저장소를 사용한다고 해서 모노레포 구조라 할 수 없으며, 프로젝트 사이에 의존성이 존재하거나 같은 제품군이거나 하는 정의된 관계가 존재

### 장점
* 더 쉬운 프로젝트 생성
* 더 쉬운 의존성 관리
* 단일화된 관리 포인트
* 일관된 개발자 경험 제공

### 고려필요부분
* 코드공유 - 서로다른 프로젝트간에 쉽게 코드 공유
* 일관성 있는 도구 - 서로 다른 프로젝트들에서 일관된 개발 경험 제공
* 스케폴딩 - 새로운 프로젝트 생성시 초기코드 쉽게 생성
* 프로젝트 제약 및 가시성 - 저장소 내에서 의존 관계를 제한하는 규칙 정의 지원

## 1.3 Monorepo 관련 opensource

- [NX](https://nx.dev/getting-started/intro)
  - 최고 수준의 단일 저장소 지원 및 강력한 통합을 갖춘 차세대 빌드 시스템
  - 구글 개발자들이 만든 오픈소스 프로젝트
  - Angular, React와 같은 프런트엔드 프레임워크 기반의 개발 환경 구성뿐 아니라 Express, Nest.js와 같은 백엔드 기술 기반의 개발까지 폭넓게 지원
  - 주요특징
    - 로컬 및 CI에서 기존 프로젝트의 빌드 및 테스트 속도를 높입니다
    - 하위 수준 빌드 도구를 구성할 필요 없이 Nx 플러그인을 사용하여 새 프로젝트를 빠르게 생성가능(스캐폴드)
    - 새로운 도구(예: Storybook, Tailwind 등)를 프로젝트에 쉽게 통합
    - 맞춤형 생성기와 Lint 규칙을 사용하여 일관성과 코드 품질을 보장
    - 자동화된 코드 마이그레이션 기능을 사용하여 프레임워크와 도구를 업데이트하고 작업 공간을 상시 유지
- [Turborepo](https://turbo.build/repo)
  - Turbo는 Rust로 작성된 JavaScript 및 TypeScript에 최적화된 증분 번들러 및 빌드 시스템
  - 주요특징
    - Incremental builds - 작업 진행을 캐싱해 이미 계산된 내용은 건너 뛰는 것을 의미합니다. 빌드는 딱 한   번만 하는 것을 목표
    - Content-aware hasing - 타임스탬프가 아닌 콘텐츠를 인식하는 방식으로 해싱을 지원합니다. 이를 통해   모든 파일을 다시 빌드하는 것이 아니라 변경된 파일만 빌드
    - Cloud caching - 클라우드 빌드 캐시를 팀원 및 CI/CD와 공유합니다. 이를 통해 로컬 환경을 넘어   클라우드 환경에서도 빠른 빌드를 제공
    - Parallel execution - 모든 코어를 사용하는 병렬 실행을 목표로 합니다. 지정된 태스크 단위로 의존성을   판단해 최대한 병렬적으로 작업을 진행
    - Task Pipelines - 태스크 간의 연결을 정의해서 빌드를 언제 어떻게 실행할지 판단해 최적화
    - Zero Runtime Overhead - 런타임 코드와 소스 맵을 다루지 않기 때문에 런타임 단계에서 파악하지 못한   리스크가 불거질 위험이 없습니다.
    - Pruned subsets - 빌드에 필요한 요소만으로 모노 레포의 하위 집합을 생성해 PaaS 배포 속도를 높입니다.
    - JSON configuration - 별도의 코드 작업 없이 JSON 설정으로 터보를 사용할 수 있습니다.
    - Profile in browser - 빌드 프로필로 빌드 과정을 시각화하면 병목 지점을 쉽게 찾을 수 있습니다.
- pnpm



## 참고

- [모던 프론트엔드 프로젝트 구성 기법 - 모노레포 개념 편](https://d2.naver.com/helloworld/0923884)
- [NX](https://nx.dev/getting-started/intro)
- [Turborepo](https://turbo.build/repo)